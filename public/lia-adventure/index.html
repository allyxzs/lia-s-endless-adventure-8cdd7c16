<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lia Adventure</title>
    <meta name="description" content="Jogo de aventura side-scroller com Lia, Sarah, Dani, Alice e Vit√≥ria! Derrote esqueletos e avance pelos 5 mundos.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --primary: #ff6b9d;
            --primary-dark: #e0558a;
            --primary-glow: rgba(255, 107, 157, 0.5);
            --secondary: #4dccbd;
            --secondary-dark: #3eb3a5;
            --accent: #a9d1ff;
            --danger: #ff6b6b;
            --warning: #ffb347;
            --bg-dark: #0d1b2a;
            --bg-darker: #06101a;
            --bg-panel: rgba(13, 27, 42, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #a9d1ff;
            --gold: #ffd700;
            --xp-purple: #a855f7;
            --sarah-red: #e74c3c;
            --dani-blue: #3498db;
            --alice-orange: #e67e22;
            --vitoria-cyan: #00bcd4;
        }

        html, body { height: 100%; overflow: hidden; }

        body {
            font-family: 'Fredoka', sans-serif;
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 50%, #1a2c4a 100%);
            color: var(--text-primary);
            display: flex; align-items: center; justify-content: center;
            min-height: 100vh; padding: 0;
        }

        .game-wrapper { display: flex; flex-direction: column; align-items: center; width: 100%; height: 100%; }
        .canvas-container { position: relative; width: 100%; height: 100%; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; background: var(--bg-dark); object-fit: contain; }

        /* Compact HUD */
        .hud-overlay {
            position: absolute; top: 8px; left: 8px; right: 8px;
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: none; z-index: 10;
        }
        .hud-left, .hud-right { display: flex; gap: 4px; flex-wrap: wrap; }
        .hud-stat {
            background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 8px;
            display: flex; align-items: center; gap: 4px;
            border: 1px solid rgba(255,255,255,0.15); backdrop-filter: blur(5px);
        }
        .hud-icon { font-size: 0.65rem; }
        .hud-value { font-family: 'Press Start 2P', cursive; font-size: 0.4rem; color: var(--gold); }
        .health-bar-container { width: 50px; height: 8px; background: rgba(0,0,0,0.7); border-radius: 4px; overflow: hidden; border: 1px solid rgba(255,255,255,0.2); }
        .health-bar { height: 100%; background: linear-gradient(90deg, var(--danger), var(--warning)); transition: width 0.3s; border-radius: 3px; }
        .xp-bar-container { width: 40px; height: 6px; background: rgba(0,0,0,0.7); border-radius: 3px; overflow: hidden; }
        .xp-bar { height: 100%; background: linear-gradient(90deg, var(--xp-purple), #c084fc); transition: width 0.3s; }

        .stage-indicator {
            position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 4px 12px; border-radius: 10px;
            font-family: 'Press Start 2P', cursive; font-size: 0.4rem; color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); z-index: 11;
        }
        .mission-indicator {
            position: absolute; top: 35px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 3px 10px; border-radius: 8px;
            font-size: 0.6rem; color: var(--text-secondary); z-index: 11;
            max-width: 80%; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        /* Game Screens */
        .game-screen {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(6,16,26,0.98); backdrop-filter: blur(10px);
            z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s;
            padding: 20px; overflow-y: auto;
        }
        .game-screen.active { opacity: 1; pointer-events: auto; }

        /* Title Screen */
        #titleScreen { background: radial-gradient(ellipse at center, #1a2c4a 0%, var(--bg-darker) 70%); }
        .title-logo {
            font-family: 'Press Start 2P', cursive; font-size: clamp(1.5rem, 5vw, 3rem);
            color: var(--primary);
            text-shadow: 0 0 30px var(--primary-glow), 4px 4px 0 var(--primary-dark), -2px -2px 0 #fff;
            margin-bottom: 50px; animation: titleFloat 3s ease-in-out infinite; text-align: center;
        }
        @keyframes titleFloat { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }
        .press-start {
            font-family: 'Press Start 2P', cursive; font-size: clamp(0.6rem, 2vw, 1rem);
            color: var(--text-primary); animation: blink 1s infinite; margin-bottom: 30px;
        }
        @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
        .start-btn-big {
            font-family: 'Press Start 2P', cursive; font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            padding: 20px 60px; border: none; border-radius: 60px; cursor: pointer;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white;
            box-shadow: 0 8px 0 #b03e6a, 0 12px 30px rgba(255,107,157,0.4); transition: all 0.2s;
        }
        .start-btn-big:hover { transform: translateY(-3px); box-shadow: 0 11px 0 #b03e6a, 0 18px 40px rgba(255,107,157,0.5); }
        .start-btn-big:active { transform: translateY(4px); box-shadow: 0 4px 0 #b03e6a; }

        /* Main Menu */
        #mainMenuScreen .menu-title {
            font-family: 'Press Start 2P', cursive; font-size: clamp(1rem, 3vw, 1.8rem);
            color: var(--primary); text-shadow: 0 0 20px var(--primary-glow); margin-bottom: 40px;
        }
        .menu-options { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 350px; }
        .menu-btn {
            font-family: 'Press Start 2P', cursive; font-size: clamp(0.5rem, 1.5vw, 0.75rem);
            padding: 18px 30px; border: 3px solid transparent; border-radius: 15px;
            cursor: pointer; transition: all 0.3s; text-align: center; width: 100%;
        }
        .menu-btn-primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; box-shadow: 0 5px 0 #b03e6a; }
        .menu-btn-primary:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #b03e6a; }
        .menu-btn-secondary-style { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); color: var(--text-primary); }
        .menu-btn-secondary-style:hover { background: rgba(255,255,255,0.2); border-color: var(--secondary); }
        .menu-btn-google { background: linear-gradient(135deg, #4285f4, #356ac3); color: white; box-shadow: 0 5px 0 #2a5298; }
        .menu-btn-google:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #2a5298; }
        .google-hint { font-size: 0.65rem; color: var(--text-secondary); margin-top: -5px; opacity: 0.8; }

        /* Stage Select */
        #stageSelectScreen { padding: 10px; }
        .stage-select-header { display: flex; justify-content: space-between; align-items: center; width: 100%; max-width: 900px; margin-bottom: 15px; }
        .stage-select-title { font-family: 'Press Start 2P', cursive; font-size: clamp(0.7rem, 2vw, 1rem); color: var(--secondary); }
        .back-btn {
            font-family: 'Press Start 2P', cursive; font-size: 0.5rem; padding: 8px 15px;
            border: 2px solid var(--text-secondary); border-radius: 8px;
            background: transparent; color: var(--text-secondary); cursor: pointer; transition: all 0.2s;
        }
        .back-btn:hover { border-color: var(--primary); color: var(--primary); }

        .player-stats-panel {
            display: flex; gap: 20px; background: rgba(0,0,0,0.4); padding: 10px 20px;
            border-radius: 12px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center;
        }
        .player-stat-item { text-align: center; }
        .player-stat-value { font-family: 'Press Start 2P', cursive; font-size: 0.7rem; color: var(--gold); }
        .player-stat-label { font-size: 0.6rem; color: var(--text-secondary); }

        .world-tabs { display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center; }
        .world-tab {
            font-family: 'Press Start 2P', cursive; font-size: 0.35rem; padding: 8px 12px;
            border: 2px solid rgba(255,255,255,0.2); border-radius: 8px;
            background: rgba(0,0,0,0.3); color: var(--text-secondary); cursor: pointer; transition: all 0.2s;
        }
        .world-tab.active { border-color: var(--primary); background: var(--primary); color: white; }
        .world-tab:hover:not(.active) { border-color: var(--secondary); }

        .stage-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px; width: 100%; max-width: 900px; max-height: 40vh;
            overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 15px;
        }
        .stage-node {
            aspect-ratio: 1; border-radius: 12px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s;
            border: 3px solid transparent; position: relative; min-width: 70px;
        }
        .stage-node.unlocked { background: linear-gradient(135deg, #2d4a6d, #3d5a80); border-color: var(--secondary); }
        .stage-node.unlocked:hover { transform: scale(1.05); border-color: var(--primary); box-shadow: 0 0 20px var(--primary-glow); }
        .stage-node.completed { background: linear-gradient(135deg, #3a5a40, #588157); border-color: #7cb342; }
        .stage-node.completed::after { content: '‚≠ê'; position: absolute; top: -5px; right: -5px; font-size: 0.8rem; }
        .stage-node.locked { background: rgba(0,0,0,0.4); border-color: rgba(255,255,255,0.1); cursor: not-allowed; opacity: 0.5; }
        .stage-node.current { animation: currentPulse 1.5s infinite; }
        @keyframes currentPulse { 0%,100%{box-shadow:0 0 10px var(--primary-glow)} 50%{box-shadow:0 0 25px var(--primary-glow),0 0 40px var(--primary-glow)} }
        .stage-number { font-family: 'Press Start 2P', cursive; font-size: 0.8rem; color: white; }
        .stage-stars { font-size: 0.5rem; margin-top: 3px; }

        .stage-info-panel {
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 12px;
            margin-top: 15px; width: 100%; max-width: 500px; text-align: center;
        }
        .stage-info-title { font-family: 'Press Start 2P', cursive; font-size: 0.6rem; color: var(--primary); margin-bottom: 8px; }
        .stage-info-mission { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 10px; }
        .stage-info-rewards { display: flex; justify-content: center; gap: 15px; margin-bottom: 10px; }
        .reward-item { display: flex; align-items: center; gap: 5px; font-size: 0.65rem; color: var(--gold); }
        .play-stage-btn {
            font-family: 'Press Start 2P', cursive; font-size: 0.6rem; padding: 12px 30px;
            border: none; border-radius: 25px; cursor: pointer;
            background: linear-gradient(135deg, var(--secondary), var(--secondary-dark)); color: white;
            box-shadow: 0 4px 0 #2a9d8f; transition: all 0.2s;
        }
        .play-stage-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 #2a9d8f; }

        /* Team Select */
        .team-select-mini { display: flex; gap: 10px; margin-bottom: 15px; justify-content: center; flex-wrap: wrap; }
        .team-char-mini {
            width: 55px; height: 65px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.4); display: flex; flex-direction: column;
            align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
            padding: 3px;
        }
        .team-char-mini.selected { border-color: var(--secondary); background: rgba(77,204,189,0.2); }
        .team-char-mini.locked { opacity: 0.4; cursor: not-allowed; }
        .team-char-mini img { width: 35px; height: 35px; image-rendering: pixelated; }
        .team-char-mini .char-name { font-size: 0.4rem; color: var(--text-secondary); font-family: 'Press Start 2P', cursive; margin-top: 2px; }
        .team-char-mini .char-role { font-size: 0.3rem; color: var(--gold); }

        /* Results Screen */
        .results-screen {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(6,16,26,0.95); z-index: 90;
            opacity: 0; pointer-events: none; transition: opacity 0.5s; padding: 20px;
        }
        .results-screen.active { opacity: 1; pointer-events: auto; }

        .results-title {
            font-family: 'Press Start 2P', cursive; font-size: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 25px; text-shadow: 0 0 20px currentColor;
        }
        .results-title.victory { color: var(--secondary); }
        .results-title.defeat { color: var(--danger); }

        .results-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
            margin-bottom: 20px; width: 100%; max-width: 350px;
        }
        .result-card {
            background: rgba(255,255,255,0.05); padding: 12px; border-radius: 10px;
            text-align: center; border: 1px solid rgba(255,255,255,0.1);
        }
        .result-card-value { font-family: 'Press Start 2P', cursive; font-size: 0.7rem; color: var(--gold); }
        .result-card-label { font-size: 0.6rem; color: var(--text-secondary); margin-top: 4px; }

        .result-xp {
            font-family: 'Press Start 2P', cursive; font-size: 0.8rem; color: var(--xp-purple);
            margin-bottom: 10px;
        }
        .result-levelup {
            font-family: 'Press Start 2P', cursive; font-size: 1rem; color: var(--gold);
            animation: levelUpPulse 0.5s ease-in-out infinite alternate; margin-bottom: 10px;
        }
        @keyframes levelUpPulse { from{transform:scale(1)} to{transform:scale(1.1)} }

        .result-unlock {
            font-family: 'Press Start 2P', cursive; font-size: 0.65rem; color: var(--secondary);
            background: rgba(77,204,189,0.15); padding: 10px 20px; border-radius: 10px;
            border: 1px solid var(--secondary); margin-bottom: 15px;
            animation: unlockGlow 1s ease-in-out infinite alternate;
        }
        @keyframes unlockGlow { from{box-shadow:0 0 10px rgba(77,204,189,0.3)} to{box-shadow:0 0 25px rgba(77,204,189,0.6)} }

        .results-buttons { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }

        .game-btn {
            font-family: 'Press Start 2P', cursive; font-size: 0.6rem; padding: 12px 25px;
            border: none; border-radius: 50px; cursor: pointer; transition: all 0.2s; text-transform: uppercase;
            display: flex; align-items: center; gap: 8px;
        }
        .game-btn-primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; box-shadow: 0 5px 0 #b03e6a; }
        .game-btn-primary:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #b03e6a; }
        .game-btn-secondary { background: linear-gradient(135deg, var(--secondary), var(--secondary-dark)); color: white; box-shadow: 0 5px 0 #2a9d8f; }
        .game-btn-secondary:hover { transform: translateY(-2px); box-shadow: 0 7px 0 #2a9d8f; }
        .game-btn-danger { background: linear-gradient(135deg, var(--danger), #c0392b); color: white; box-shadow: 0 5px 0 #962d22; }

        /* Mobile Controls */
        .mobile-controls {
            display: none; position: fixed; bottom: 10px; left: 0; right: 0;
            padding: 0 10px; justify-content: space-between; z-index: 1000;
        }
        .mobile-btn-group { display: flex; gap: 8px; }
        .mobile-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 3px solid rgba(255,255,255,0.4);
            background: rgba(13,27,42,0.85); color: white; font-size: 1.5rem;
            display: flex; align-items: center; justify-content: center;
            touch-action: manipulation; user-select: none; -webkit-user-select: none;
        }
        .mobile-btn:active { background: rgba(255,107,157,0.5); transform: scale(0.95); }
        .mobile-btn.attack { background: rgba(255,107,157,0.4); border-color: var(--primary); }
        .mobile-btn.jump { background: rgba(77,204,189,0.4); border-color: var(--secondary); }
        .mobile-btn.support { background: rgba(52,152,219,0.4); border-color: var(--dani-blue); }
        .mobile-btn.skill1 { background: rgba(230,126,34,0.4); border-color: var(--alice-orange); font-size: 1.2rem; }
        .mobile-btn.skill2 { background: rgba(0,188,212,0.4); border-color: var(--vitoria-cyan); font-size: 1.2rem; }

        .support-cooldown {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 4px 12px; border-radius: 12px;
            font-family: 'Press Start 2P', cursive; font-size: 0.4rem; color: var(--dani-blue); z-index: 20; display: none;
        }

        /* Overlays */
        .combo-display {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
            font-family: 'Press Start 2P', cursive; font-size: 1.2rem; color: var(--gold);
            text-shadow: 0 0 20px var(--gold), 2px 2px 0 #b38600;
            pointer-events: none; opacity: 0; z-index: 50;
        }
        .combo-display.active { animation: comboPopup 0.8s ease-out forwards; }
        @keyframes comboPopup { 0%{opacity:0;transform:translate(-50%,-50%) scale(0.5)} 20%{opacity:1;transform:translate(-50%,-50%) scale(1.2)} 100%{opacity:0;transform:translate(-50%,-80%) scale(1)} }

        .levelup-display {
            position: absolute; top: 25%; left: 50%; transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive; font-size: 1rem; color: var(--secondary);
            text-shadow: 0 0 30px var(--secondary); pointer-events: none; opacity: 0; z-index: 50;
        }
        .levelup-display.active { animation: levelUpPopup 1.5s ease-out forwards; }
        @keyframes levelUpPopup { 0%{opacity:0;transform:translateX(-50%) translateY(20px) scale(0.8)} 20%{opacity:1;transform:translateX(-50%) translateY(0) scale(1.1)} 80%{opacity:1} 100%{opacity:0;transform:translateX(-50%) translateY(-30px)} }

        .unlock-display {
            position: absolute; top: 30%; left: 50%; transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive; font-size: 0.8rem; color: var(--secondary);
            text-shadow: 0 0 30px var(--secondary); pointer-events: none; opacity: 0; z-index: 50; text-align: center;
        }
        .unlock-display.active { animation: unlockPopup 3s ease-out forwards; }
        @keyframes unlockPopup { 0%{opacity:0;transform:translateX(-50%) scale(0.5)} 15%{opacity:1;transform:translateX(-50%) scale(1.2)} 85%{opacity:1} 100%{opacity:0} }

        .pause-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-family: 'Press Start 2P', cursive; font-size: 1.5rem; color: var(--text-primary);
            text-shadow: 0 0 20px var(--primary); z-index: 60; display: none;
        }
        .pause-overlay.active { display: block; animation: pausePulse 1s ease-in-out infinite; }
        @keyframes pausePulse { 0%,100%{opacity:0.7} 50%{opacity:1} }

        /* Loading */
        .loading-screen {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-darker); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 200;
        }
        .loading-spinner { width: 50px; height: 50px; border: 4px solid rgba(255,107,157,0.2); border-top-color: var(--primary); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { to{transform:rotate(360deg)} }
        .loading-text { font-family: 'Press Start 2P', cursive; font-size: 0.6rem; color: var(--text-secondary); animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%,100%{opacity:0.5} 50%{opacity:1} }

        /* Desktop Controls */
        .controls-panel {
            display: none; position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 8px 20px; border-radius: 10px;
            grid-template-columns: repeat(5, auto); gap: 15px; z-index: 20;
        }
        .control-item { display: flex; align-items: center; gap: 5px; }
        .control-label { color: var(--text-secondary); font-size: 0.65rem; }
        .key {
            display: inline-flex; align-items: center; justify-content: center;
            background: linear-gradient(180deg, #3a4d6e, #2a3d5e);
            min-width: 22px; height: 20px; padding: 0 5px; border-radius: 4px;
            font-family: 'Press Start 2P', cursive; font-size: 0.35rem; color: var(--text-primary);
            box-shadow: 0 2px 0 #1a2639;
        }

        @media (max-width: 768px) {
            .mobile-controls { display: flex; }
            .stage-grid { grid-template-columns: repeat(5, 1fr); }
            .stage-node { min-width: 50px; }
            .stage-number { font-size: 0.6rem; }
        }
        @media (max-width: 480px) {
            .mobile-btn { width: 55px; height: 55px; font-size: 1.3rem; }
            .stage-grid { grid-template-columns: repeat(4, 1fr); }
        }
        @media (min-width: 769px) { .controls-panel { display: grid; } }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="canvas-container">
            <canvas id="gameCanvas"></canvas>

            <div class="stage-indicator" id="stageIndicator" style="display:none;">FASE 1-1</div>
            <div class="mission-indicator" id="missionIndicator" style="display:none;">Derrote 5 esqueletos</div>

            <div class="hud-overlay" id="hudOverlay" style="display:none;">
                <div class="hud-left">
                    <div class="hud-stat">
                        <span class="hud-icon">‚ù§Ô∏è</span>
                        <div class="health-bar-container"><div class="health-bar" id="healthBar" style="width:100%;"></div></div>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-icon">‚ö°</span>
                        <div class="xp-bar-container"><div class="xp-bar" id="xpBar" style="width:0%;"></div></div>
                        <span class="hud-value" id="levelDisplay">Lv.1</span>
                    </div>
                </div>
                <div class="hud-right">
                    <div class="hud-stat">
                        <span class="hud-icon">üíÄ</span>
                        <span class="hud-value" id="killsDisplay">0/5</span>
                    </div>
                    <div class="hud-stat">
                        <span class="hud-icon">‚≠ê</span>
                        <span class="hud-value" id="scoreDisplay">0</span>
                    </div>
                </div>
            </div>

            <div class="support-cooldown" id="supportCooldown">üõ°Ô∏è SHIELD: PRONTO (K)</div>
            <div class="combo-display" id="comboDisplay"></div>
            <div class="levelup-display" id="levelUpDisplay"></div>
            <div class="unlock-display" id="unlockDisplay"></div>
            <div class="pause-overlay" id="pauseOverlay">PAUSADO</div>

            <div class="loading-screen" id="loadingScreen">
                <div class="loading-spinner"></div>
                <div class="loading-text">CARREGANDO...</div>
            </div>

            <!-- TITLE SCREEN -->
            <div class="game-screen active" id="titleScreen">
                <h1 class="title-logo">LIA ADVENTURE</h1>
                <p class="press-start">PRESS START</p>
                <button class="start-btn-big" id="titleStartBtn">START</button>
            </div>

            <!-- MAIN MENU -->
            <div class="game-screen" id="mainMenuScreen">
                <h2 class="menu-title">LIA ADVENTURE</h2>
                <div class="menu-options">
                    <button class="menu-btn menu-btn-primary" id="playGameBtn">INICIAR JOGO</button>
                    <button class="menu-btn menu-btn-google" id="googleLoginBtn">üîµ LOGAR CONTA GOOGLE</button>
                    <p class="google-hint">Essa op√ß√£o √© para salvar seus dados de jogo.</p>
                </div>
            </div>

            <!-- STAGE SELECT -->
            <div class="game-screen" id="stageSelectScreen">
                <div class="stage-select-header">
                    <h2 class="stage-select-title">SELECIONAR FASE</h2>
                    <button class="back-btn" id="backToMenuBtn">‚Üê VOLTAR</button>
                </div>
                <div class="player-stats-panel">
                    <div class="player-stat-item">
                        <div class="player-stat-value" id="playerLevelStat">Lv. 1</div>
                        <div class="player-stat-label">N√≠vel</div>
                    </div>
                    <div class="player-stat-item">
                        <div class="player-stat-value" id="playerXpStat">0</div>
                        <div class="player-stat-label">XP Total</div>
                    </div>
                    <div class="player-stat-item">
                        <div class="player-stat-value" id="playerStarsStat">0</div>
                        <div class="player-stat-label">‚≠ê Estrelas</div>
                    </div>
                </div>
                <div class="world-tabs" id="worldTabs"></div>
                <div class="stage-grid" id="stageGrid"></div>
                <div class="stage-info-panel" id="stageInfoPanel" style="display:none;">
                    <div class="stage-info-title" id="stageInfoTitle">FASE 1-1</div>
                    <div class="stage-info-mission" id="stageInfoMission">Derrote 5 esqueletos para avan√ßar.</div>
                    <div class="stage-info-rewards">
                        <div class="reward-item">üèÜ <span id="stageXpReward">50</span> XP</div>
                        <div class="reward-item">‚≠ê <span id="stageScoreReward">500</span> pts</div>
                    </div>
                    <div class="team-select-mini" id="teamSelectMini"></div>
                    <button class="play-stage-btn" id="playStageBtn">JOGAR FASE</button>
                </div>
            </div>

            <!-- RESULTS SCREEN -->
            <div class="results-screen" id="resultsScreen">
                <h2 class="results-title" id="resultsTitle">FASE COMPLETA!</h2>
                <div class="results-grid" id="resultsGrid"></div>
                <div class="result-xp" id="resultXp" style="display:none;"></div>
                <div class="result-levelup" id="resultLevelUp" style="display:none;">üéâ LEVEL UP! üéâ</div>
                <div class="result-unlock" id="resultUnlock" style="display:none;"></div>
                <div class="results-buttons" id="resultsButtons"></div>
            </div>

            <!-- Desktop Controls -->
            <div class="controls-panel" id="controlsPanel">
                <div class="control-item"><span class="control-label">Mover:</span><span class="key">A</span><span class="key">D</span></div>
                <div class="control-item"><span class="control-label">Pular:</span><span class="key">W</span><span class="key">ESPA√áO</span></div>
                <div class="control-item"><span class="control-label">Atacar:</span><span class="key">J</span></div>
                <div class="control-item"><span class="control-label">Skill:</span><span class="key">K</span><span class="key">L</span></div>
                <div class="control-item"><span class="control-label">Pausar:</span><span class="key">ESC</span></div>
            </div>
        </div>
    </div>

    <!-- Mobile Controls -->
    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-btn-group">
            <button class="mobile-btn" id="mobileLeft">‚óÄ</button>
            <button class="mobile-btn" id="mobileRight">‚ñ∂</button>
        </div>
        <div class="mobile-btn-group">
            <button class="mobile-btn skill2" id="mobileSkill2" style="display:none;">‚ùÑÔ∏è</button>
            <button class="mobile-btn skill1" id="mobileSkill1" style="display:none;">üî•</button>
            <button class="mobile-btn support" id="mobileSupport">üõ°Ô∏è</button>
            <button class="mobile-btn jump" id="mobileJump">‚ñ≤</button>
            <button class="mobile-btn attack" id="mobileAttack">‚öî</button>
        </div>
    </div>

    <script>
        // ============================================
        // LIA ADVENTURE - Game Engine v5.0
        // 5 Worlds, 30 Stages, 5 Characters
        // Lia, Sarah, Dani, Alice, Vit√≥ria
        // ============================================

        const WORLDS = [
            'Magewood Forest',
            'Lunar Cave',
            'Peak of Justice',
            'The Vermilion City',
            'Arc Island'
        ];

        const STAGES_DATA = [];

        // Generate 30 stages (6 per world)
        for (let world = 0; world < 5; world++) {
            for (let stage = 0; stage < 6; stage++) {
                const stageNum = world * 6 + stage + 1;

                let mission;
                if (stage === 5) {
                    mission = { type: 'kill', text: `Derrote ${10 + stageNum * 3} esqueletos + Chefe`, target: 10 + stageNum * 3, hasBoss: true };
                } else if (stage % 3 === 0) {
                    const t = 5 + stageNum * 2;
                    mission = { type: 'kill', text: `Derrote ${t} esqueletos`, target: t };
                } else if (stage % 3 === 1) {
                    const t = 30 + stageNum * 5;
                    mission = { type: 'survive', text: `Sobreviva por ${t} segundos`, target: t };
                } else {
                    const t = 3 + Math.floor(stageNum / 5);
                    mission = { type: 'combo', text: `Alcance combo ${t}x`, target: t };
                }

                let unlockChar = null;
                if (stageNum === 2) unlockChar = 'sarah';
                if (stageNum === 8) unlockChar = 'dani';
                if (stageNum === 15) unlockChar = 'alice';
                if (stageNum === 23) unlockChar = 'vitoria';

                STAGES_DATA.push({
                    id: stageNum,
                    world: world + 1,
                    worldName: WORLDS[world],
                    stageInWorld: stage + 1,
                    name: `${world + 1}-${stage + 1}`,
                    mission: mission,
                    enemyHealth: 40 + stageNum * 8,
                    enemyDamage: 8 + stageNum * 2,
                    enemySpeed: 1.5 + stageNum * 0.08,
                    maxEnemies: Math.min(3 + Math.floor(stageNum / 4), 10),
                    spawnRate: Math.max(800, 2500 - stageNum * 50),
                    xpReward: 50 + stageNum * 30,
                    scoreReward: 300 + stageNum * 100,
                    unlockChar: unlockChar
                });
            }
        }

        // XP System
        const XP_SYSTEM = {
            getXpForLevel(level) { return Math.floor(100 * Math.pow(1.5, level - 1)); },
            getTotalXpForLevel(level) { let t = 0; for (let i = 1; i < level; i++) t += this.getXpForLevel(i); return t; },
            getLevelFromXp(totalXp) {
                let level = 1, xpNeeded = 0;
                while (totalXp >= xpNeeded + this.getXpForLevel(level)) { xpNeeded += this.getXpForLevel(level); level++; if (level > 99) break; }
                return { level, currentXp: totalXp - xpNeeded, neededXp: this.getXpForLevel(level) };
            },
            getStatBonus(level, stat) {
                const b = { attack: level * 3, health: level * 10, speed: Math.min(level * 0.1, 3) };
                return b[stat] || 0;
            }
        };

        // Config
        const CONFIG = {
            canvas: { width: 1280, height: 720 },
            physics: { gravity: 0.5, friction: 0.89, groundY: 620, airResistance: 0.98 },
            player: {
                width: 70, height: 100, walkSpeed: 4, runSpeed: 7, maxSpeed: 9,
                acceleration: 0.45, deceleration: 0.35, jumpForce: -14, jumpHoldForce: -0.5,
                maxJumpHoldTime: 200, attackDuration: 300, attackCooldown: 400,
                damageCooldown: 1000, attackRange: 90, attackHeight: 70,
                baseHealth: 100, baseAttack: 20
            },
            sarah: { width: 65, height: 95, projectileSpeed: 10, attackRange: 400, attackCooldown: 600, baseAttack: 15 },
            dani: { width: 70, height: 100, shieldDuration: 6000, shieldCooldown: 15000 },
            alice: { width: 65, height: 95, fireRadius: 150, burnDamage: 3, burnDuration: 3000, buffDuration: 5000, attackCooldown: 8000 },
            vitoria: { width: 65, height: 95, iceRange: 350, freezeChance: 0.25, freezeDuration: 2000, skill1Cooldown: 5000, skill2Cooldown: 12000, skill3Cooldown: 10000 },
            scoring: { killBase: 100, comboMultiplier: 1.5, comboTimeout: 2000 }
        };

        // Game State
        const gameState = {
            totalXp: 0, playerLevel: 1, currentXp: 0, xpToNextLevel: 100,
            highestStage: 1, stageStars: {},
            unlockedChars: { lia: true, sarah: false, dani: false, alice: false, vitoria: false },
            totalScore: 0,
            currentStage: null, selectedCharacters: ['lia'],
            sarahInTeam: false, daniInTeam: false, aliceInTeam: false, vitoriaInTeam: false,
            running: false, paused: false, stageComplete: false, playerDied: false,
            stageKills: 0, stageScore: 0, stageDamageTaken: 0, stageMaxCombo: 0,
            stageStartTime: 0, combo: 0, lastComboTime: 0, lastSpawnTime: 0,
            backgroundOffset: 0, particles: [], damageIndicators: [],
            screenShake: { x: 0, y: 0, intensity: 0 }, keys: {},
            projectiles: [],
            shieldActive: false, shieldEndTime: 0, lastShieldTime: 0,
            // Alice buffs
            attackBuff: false, attackBuffEnd: 0,
            // Vit√≥ria buffs
            iceShieldActive: false, iceShieldEnd: 0,
            frostComboActive: false, frostComboEnd: 0, frostComboChance: 0,
            isLoggedIn: false
        };

        // Save/Load - ONLY saves if logged in
        function saveProgress() {
            if (!gameState.isLoggedIn) return; // Only save if logged in
            localStorage.setItem('liaAdventureSave', JSON.stringify({
                totalXp: gameState.totalXp, highestStage: gameState.highestStage,
                stageStars: gameState.stageStars, unlockedChars: gameState.unlockedChars,
                totalScore: gameState.totalScore
            }));
        }
        function loadProgress() {
            if (!gameState.isLoggedIn) return;
            const saved = localStorage.getItem('liaAdventureSave');
            if (saved) {
                const d = JSON.parse(saved);
                gameState.totalXp = d.totalXp || 0;
                gameState.highestStage = d.highestStage || 1;
                gameState.stageStars = d.stageStars || {};
                gameState.unlockedChars = d.unlockedChars || { lia: true, sarah: false, dani: false, alice: false, vitoria: false };
                gameState.totalScore = d.totalScore || 0;
                const li = XP_SYSTEM.getLevelFromXp(gameState.totalXp);
                gameState.playerLevel = li.level; gameState.currentXp = li.currentXp; gameState.xpToNextLevel = li.neededXp;
            }
        }

        // DOM
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const el = {
            loadingScreen: document.getElementById('loadingScreen'),
            titleScreen: document.getElementById('titleScreen'),
            mainMenuScreen: document.getElementById('mainMenuScreen'),
            stageSelectScreen: document.getElementById('stageSelectScreen'),
            resultsScreen: document.getElementById('resultsScreen'),
            resultsTitle: document.getElementById('resultsTitle'),
            resultsGrid: document.getElementById('resultsGrid'),
            resultXp: document.getElementById('resultXp'),
            resultLevelUp: document.getElementById('resultLevelUp'),
            resultUnlock: document.getElementById('resultUnlock'),
            resultsButtons: document.getElementById('resultsButtons'),
            hudOverlay: document.getElementById('hudOverlay'),
            stageIndicator: document.getElementById('stageIndicator'),
            missionIndicator: document.getElementById('missionIndicator'),
            healthBar: document.getElementById('healthBar'),
            xpBar: document.getElementById('xpBar'),
            levelDisplay: document.getElementById('levelDisplay'),
            killsDisplay: document.getElementById('killsDisplay'),
            scoreDisplay: document.getElementById('scoreDisplay'),
            supportCooldown: document.getElementById('supportCooldown'),
            comboDisplay: document.getElementById('comboDisplay'),
            levelUpDisplay: document.getElementById('levelUpDisplay'),
            unlockDisplay: document.getElementById('unlockDisplay'),
            pauseOverlay: document.getElementById('pauseOverlay'),
            controlsPanel: document.getElementById('controlsPanel'),
            mobileControls: document.getElementById('mobileControls'),
            worldTabs: document.getElementById('worldTabs'),
            stageGrid: document.getElementById('stageGrid'),
            stageInfoPanel: document.getElementById('stageInfoPanel'),
            stageInfoTitle: document.getElementById('stageInfoTitle'),
            stageInfoMission: document.getElementById('stageInfoMission'),
            stageXpReward: document.getElementById('stageXpReward'),
            stageScoreReward: document.getElementById('stageScoreReward'),
            teamSelectMini: document.getElementById('teamSelectMini'),
            playerLevelStat: document.getElementById('playerLevelStat'),
            playerXpStat: document.getElementById('playerXpStat'),
            playerStarsStat: document.getElementById('playerStarsStat'),
        };

        // Canvas resize
        function resizeCanvas() {
            const c = canvas.parentElement;
            const ar = CONFIG.canvas.width / CONFIG.canvas.height;
            let w = c.clientWidth, h = w / ar;
            if (h > c.clientHeight) { h = c.clientHeight; w = h * ar; }
            canvas.width = CONFIG.canvas.width; canvas.height = CONFIG.canvas.height;
            canvas.style.width = `${w}px`; canvas.style.height = `${h}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Audio
        let audioCtx = null;
        function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        function playTone(freq, dur, type='square', vol=0.1) {
            if (!audioCtx) return;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = type; o.frequency.value = freq; g.gain.value = vol;
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + dur);
        }
        const sounds = {
            jump: () => playTone(400, 0.1, 'square', 0.08),
            attack: () => playTone(200, 0.15, 'sawtooth', 0.1),
            hit: () => playTone(150, 0.1, 'square', 0.12),
            damage: () => playTone(100, 0.2, 'sawtooth', 0.15),
            shield: () => { playTone(300, 0.1, 'sine', 0.1); setTimeout(() => playTone(500, 0.15, 'sine', 0.1), 100); },
            shoot: () => playTone(600, 0.08, 'sine', 0.08),
            combo: () => playTone(800, 0.1, 'sine', 0.1),
            fire: () => { playTone(250, 0.2, 'sawtooth', 0.12); setTimeout(() => playTone(350, 0.15, 'sawtooth', 0.1), 100); },
            ice: () => { playTone(700, 0.15, 'sine', 0.1); setTimeout(() => playTone(900, 0.1, 'sine', 0.08), 100); },
            stageComplete: () => { playTone(523, 0.15); setTimeout(() => playTone(659, 0.15), 150); setTimeout(() => playTone(784, 0.2), 300); setTimeout(() => playTone(1047, 0.3), 450); },
            unlock: () => { for(let i = 0; i < 5; i++) setTimeout(() => playTone(400 + i * 100, 0.1, 'sine', 0.12), i * 80); },
            levelUp: () => { playTone(523, 0.1); setTimeout(() => playTone(784, 0.1), 100); setTimeout(() => playTone(1047, 0.2), 200); },
            gameOver: () => { playTone(200, 0.3, 'sawtooth', 0.12); setTimeout(() => playTone(150, 0.4, 'sawtooth', 0.1), 300); }
        };

        // Images
        const images = {
            playerIdle: new Image(), playerWalk: new Image(), playerRun: new Image(),
            playerJump: new Image(), playerAttack: new Image(), playerDamage: new Image(),
            sarahIdle: new Image(), sarahRun: new Image(), sarahJump: new Image(),
            sarahAttack: new Image(), sarahDamage: new Image(),
            daniIdle: new Image(), daniRun: new Image(), daniJump: new Image(),
            daniDefense: new Image(), daniDamage: new Image(),
            aliceIdle: new Image(), aliceRun: new Image(),
            aliceAttack: new Image(), aliceDamage: new Image(),
            vitoriaIdle: new Image(), vitoriaRun: new Image(),
            vitoriaAttack1: new Image(), vitoriaAttack2: new Image(), vitoriaAttack3: new Image(),
            enemyIdle: new Image(), enemyWalkL: new Image(), enemyWalkR: new Image(),
            enemyAttack: new Image(), enemyDamage: new Image(), enemyDead: new Image(),
            background: new Image()
        };

        images.playerIdle.src = 'lia.png'; images.playerWalk.src = 'liawalk.png';
        images.playerRun.src = 'liarun.png'; images.playerJump.src = 'liajump.png';
        images.playerAttack.src = 'liaattacking.png'; images.playerDamage.src = 'liadamage.png';
        images.sarahIdle.src = 'sarah.png'; images.sarahRun.src = 'sarahrun.png';
        images.sarahJump.src = 'sarahjump.png'; images.sarahAttack.src = 'sarahattack.png';
        images.sarahDamage.src = 'sarahdamage.png';
        images.daniIdle.src = 'dani.png'; images.daniRun.src = 'danirun.png';
        images.daniJump.src = 'danijump.png'; images.daniDefense.src = 'danidefense.png';
        images.daniDamage.src = 'danidamage.png';
        images.aliceIdle.src = 'alice.png'; images.aliceRun.src = 'alicerun.png';
        images.aliceAttack.src = 'aliceattack.png'; images.aliceDamage.src = 'alicedamage.png';
        images.vitoriaIdle.src = 'vitoria.png'; images.vitoriaRun.src = 'vitoriarun.png';
        images.vitoriaAttack1.src = 'vitoriaattack1.png'; images.vitoriaAttack2.src = 'vitoriaattack2.png';
        images.vitoriaAttack3.src = 'vitoriaattack3.png';
        images.enemyIdle.src = 'skeleton.png'; images.enemyWalkL.src = 'skeletonwalkl.png';
        images.enemyWalkR.src = 'skeletonwalkr.png'; images.enemyAttack.src = 'skeletonattack.png';
        images.enemyDamage.src = 'skeletondamage.png'; images.enemyDead.src = 'skeletonko.png';
        images.background.src = 'mapa.png';

        let imagesLoaded = 0;
        const totalImages = Object.keys(images).length;
        function onImageLoad() { imagesLoaded++; if (imagesLoaded >= totalImages) { el.loadingScreen.style.display = 'none'; } }
        Object.values(images).forEach(img => { img.onload = onImageLoad; img.onerror = onImageLoad; });

        // ================ ENTITIES ================
        let enemies = [];

        function checkCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        // Player (Lia)
        const player = {
            x: 100, y: CONFIG.physics.groundY - CONFIG.player.height,
            width: CONFIG.player.width, height: CONFIG.player.height,
            velocityX: 0, velocityY: 0,
            health: CONFIG.player.baseHealth, maxHealth: CONFIG.player.baseHealth,
            attackPower: CONFIG.player.baseAttack,
            isGrounded: false, isJumping: false, isAttacking: false,
            isDamaged: false, isRunning: false, facingRight: true,
            lastAttackTime: 0, lastDamageTime: 0, jumpHoldTime: 0, jumpPressed: false,

            reset() {
                const hb = XP_SYSTEM.getStatBonus(gameState.playerLevel, 'health');
                const ab = XP_SYSTEM.getStatBonus(gameState.playerLevel, 'attack');
                this.maxHealth = CONFIG.player.baseHealth + hb; this.health = this.maxHealth;
                this.attackPower = CONFIG.player.baseAttack + ab;
                this.x = 100; this.y = CONFIG.physics.groundY - this.height;
                this.velocityX = 0; this.velocityY = 0;
                this.isGrounded = false; this.isJumping = false; this.isAttacking = false;
                this.isDamaged = false; this.isRunning = false; this.facingRight = true;
                this.lastAttackTime = 0; this.lastDamageTime = 0; this.jumpHoldTime = 0; this.jumpPressed = false;
            },

            update(dt) {
                const now = Date.now();
                const sb = XP_SYSTEM.getStatBonus(gameState.playerLevel, 'speed');
                this.isRunning = gameState.keys['shift'];
                const ts = (this.isRunning ? CONFIG.player.runSpeed : CONFIG.player.walkSpeed) + sb;
                const a = CONFIG.player.acceleration, d = CONFIG.player.deceleration;

                if (gameState.keys['a'] || gameState.keys['arrowleft']) { this.velocityX = Math.max(this.velocityX - a, -ts); this.facingRight = false; }
                else if (gameState.keys['d'] || gameState.keys['arrowright']) { this.velocityX = Math.min(this.velocityX + a, ts); this.facingRight = true; }
                else { if (Math.abs(this.velocityX) < d) this.velocityX = 0; else this.velocityX += this.velocityX > 0 ? -d : d; }

                if (!this.isGrounded) this.velocityX *= CONFIG.physics.airResistance;
                if (this.isJumping && this.jumpPressed && this.jumpHoldTime < CONFIG.player.maxJumpHoldTime) {
                    this.velocityY += CONFIG.player.jumpHoldForce; this.jumpHoldTime += dt;
                }

                this.velocityY += CONFIG.physics.gravity;
                this.x += this.velocityX; this.y += this.velocityY;

                if (this.y >= CONFIG.physics.groundY - this.height) {
                    this.y = CONFIG.physics.groundY - this.height; this.velocityY = 0;
                    this.isGrounded = true; this.isJumping = false;
                } else { this.isGrounded = false; }

                this.x = Math.max(0, Math.min(CONFIG.canvas.width - this.width, this.x));
                if (this.isAttacking && now - this.lastAttackTime > CONFIG.player.attackDuration) this.isAttacking = false;
                if (this.isDamaged && now - this.lastDamageTime > 300) this.isDamaged = false;
            },

            jump() {
                if (this.isGrounded && !this.isJumping) {
                    this.velocityY = CONFIG.player.jumpForce; this.isJumping = true;
                    this.isGrounded = false; this.jumpHoldTime = 0; this.jumpPressed = true; sounds.jump();
                }
            },
            releaseJump() { this.jumpPressed = false; },

            attack() {
                const now = Date.now();
                if (now - this.lastAttackTime < CONFIG.player.attackCooldown) return;
                this.isAttacking = true; this.lastAttackTime = now; sounds.attack();

                let atkPower = this.attackPower;
                if (gameState.attackBuff && now < gameState.attackBuffEnd) atkPower *= 1.4;

                const ab = { x: this.facingRight ? this.x + this.width - 10 : this.x - CONFIG.player.attackRange + 10,
                    y: this.y + 20, width: CONFIG.player.attackRange, height: CONFIG.player.attackHeight };

                let hit = false;
                enemies.forEach(e => {
                    if (!e.isDead && checkCollision(ab, e)) {
                        e.takeDamage(atkPower);
                        hit = true;
                        // Frost combo check
                        if (gameState.frostComboActive && now < gameState.frostComboEnd) {
                            if (Math.random() < gameState.frostComboChance && !e.frozen) {
                                e.freeze(CONFIG.vitoria.freezeDuration);
                            }
                            gameState.frostComboChance = Math.min(gameState.frostComboChance + 0.05, 0.6);
                        }
                    }
                });

                if (hit) {
                    gameState.combo++; gameState.lastComboTime = now;
                    if (gameState.combo > gameState.stageMaxCombo) gameState.stageMaxCombo = gameState.combo;
                    if (gameState.combo > 1) { showCombo(gameState.combo); sounds.combo(); }
                    createParticles(this.facingRight ? this.x + this.width + 20 : this.x - 20, this.y + this.height / 2, '#ff6b9d', 5);
                }
            },

            takeDamage(amount) {
                const now = Date.now();
                if (now - this.lastDamageTime < CONFIG.player.damageCooldown) return;
                if (gameState.shieldActive) return;
                // Ice shield reflects damage
                if (gameState.iceShieldActive && now < gameState.iceShieldEnd) {
                    createParticles(this.x + this.width / 2, this.y + this.height / 2, '#00bcd4', 6);
                    return;
                }

                this.health -= amount; this.isDamaged = true; this.lastDamageTime = now;
                gameState.stageDamageTaken += amount; sounds.damage();
                gameState.screenShake.intensity = 8; gameState.combo = 0;
                if (gameState.frostComboActive) gameState.frostComboChance = 0.05;
                createDamageIndicator(this.x + this.width / 2, this.y, amount);
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ff6b6b', 8);

                if (this.health <= 0) { this.health = 0; gameOver(); }
                updateHUD();
            },

            draw() {
                ctx.save();
                let s = images.playerIdle;
                if (this.isDamaged) s = images.playerDamage;
                else if (this.isAttacking) s = images.playerAttack;
                else if (!this.isGrounded) s = images.playerJump;
                else if (Math.abs(this.velocityX) > 0.5) s = this.isRunning ? images.playerRun : images.playerWalk;

                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 5, this.width / 2, 10, 0, 0, Math.PI * 2); ctx.fill();

                // Attack buff glow
                if (gameState.attackBuff && Date.now() < gameState.attackBuffEnd) {
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.01) * 0.15;
                    ctx.fillStyle = '#e67e22';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.7, this.height * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Ice shield glow
                if (gameState.iceShieldActive && Date.now() < gameState.iceShieldEnd) {
                    ctx.globalAlpha = 0.25 + Math.sin(Date.now() * 0.008) * 0.1;
                    ctx.fillStyle = '#00bcd4';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width * 0.8, this.height * 0.65, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                if (!this.facingRight) { ctx.scale(-1, 1); ctx.drawImage(s, -this.x - this.width, this.y, this.width, this.height); }
                else ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        };

        // Sarah (Ranged DPS) - AI companion
        const sarah = {
            x: 160, y: CONFIG.physics.groundY - CONFIG.sarah.height,
            width: CONFIG.sarah.width, height: CONFIG.sarah.height,
            velocityX: 0, velocityY: 0, facingRight: true, isJumping: false,
            isAttacking: false, lastAttackTime: 0,

            reset() { this.x = 160; this.y = CONFIG.physics.groundY - this.height; this.velocityX = 0; this.velocityY = 0; this.facingRight = true; this.isJumping = false; this.isAttacking = false; this.lastAttackTime = 0; },

            update(dt) {
                if (!gameState.sarahInTeam) return;
                const tx = player.x + (player.facingRight ? -90 : 90);
                const dx = tx - this.x;
                if (Math.abs(dx) > 30) { this.velocityX += Math.sign(dx) * 0.35; this.velocityX = Math.max(-5, Math.min(5, this.velocityX)); this.facingRight = dx > 0; }
                else this.velocityX *= 0.8;

                if (player.isJumping && this.y >= CONFIG.physics.groundY - this.height - 5 && Math.abs(dx) < 180) { this.velocityY = -11; this.isJumping = true; }
                this.velocityY += CONFIG.physics.gravity; this.x += this.velocityX; this.y += this.velocityY;
                if (this.y >= CONFIG.physics.groundY - this.height) { this.y = CONFIG.physics.groundY - this.height; this.velocityY = 0; this.isJumping = false; }
                this.x = Math.max(0, Math.min(CONFIG.canvas.width - this.width, this.x));

                const now = Date.now();
                if (now - this.lastAttackTime > CONFIG.sarah.attackCooldown && enemies.length > 0) {
                    const alive = enemies.filter(e => !e.isDead);
                    if (alive.length > 0) {
                        const nearest = alive.reduce((a, b) => Math.abs(a.x - this.x) < Math.abs(b.x - this.x) ? a : b);
                        if (Math.abs(nearest.x - this.x) < CONFIG.sarah.attackRange) {
                            this.shootProjectile(nearest); this.lastAttackTime = now;
                            this.isAttacking = true; this.facingRight = nearest.x > this.x;
                            setTimeout(() => this.isAttacking = false, 250);
                        }
                    }
                }
            },

            shootProjectile(target) {
                let atk = CONFIG.sarah.baseAttack + XP_SYSTEM.getStatBonus(gameState.playerLevel, 'attack') * 0.5;
                if (gameState.attackBuff && Date.now() < gameState.attackBuffEnd) atk *= 1.4;
                gameState.projectiles.push({
                    x: this.x + this.width / 2, y: this.y + this.height / 2,
                    vx: (target.x > this.x ? 1 : -1) * CONFIG.sarah.projectileSpeed,
                    damage: atk, life: 1, size: 8, type: 'light'
                });
                sounds.shoot();
            },

            draw() {
                if (!gameState.sarahInTeam) return;
                ctx.save();
                let s = images.sarahIdle;
                if (this.isAttacking) s = images.sarahAttack;
                else if (this.isJumping) s = images.sarahJump;
                else if (Math.abs(this.velocityX) > 0.5) s = images.sarahRun;

                ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 3, this.width / 2.5, 8, 0, 0, Math.PI * 2); ctx.fill();

                if (!this.facingRight) { ctx.scale(-1, 1); ctx.drawImage(s, -this.x - this.width, this.y, this.width, this.height); }
                else ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        };

        // Dani (Tank/Defender)
        const dani = {
            x: 80, y: CONFIG.physics.groundY - CONFIG.dani.height,
            width: CONFIG.dani.width, height: CONFIG.dani.height,
            velocityX: 0, velocityY: 0, facingRight: true, isJumping: false,
            isDefending: false,

            reset() { this.x = 80; this.y = CONFIG.physics.groundY - this.height; this.velocityX = 0; this.velocityY = 0; this.facingRight = true; this.isJumping = false; this.isDefending = false; },

            update(dt) {
                if (!gameState.daniInTeam) return;
                const tx = player.x + (player.facingRight ? 60 : -60);
                const dx = tx - this.x;
                if (Math.abs(dx) > 20) { this.velocityX += Math.sign(dx) * 0.4; this.velocityX = Math.max(-5, Math.min(5, this.velocityX)); this.facingRight = player.facingRight; }
                else this.velocityX *= 0.8;

                if (player.isJumping && this.y >= CONFIG.physics.groundY - this.height - 5 && Math.abs(dx) < 180) { this.velocityY = -11; this.isJumping = true; }
                this.velocityY += CONFIG.physics.gravity; this.x += this.velocityX; this.y += this.velocityY;
                if (this.y >= CONFIG.physics.groundY - this.height) { this.y = CONFIG.physics.groundY - this.height; this.velocityY = 0; this.isJumping = false; }
                this.x = Math.max(0, Math.min(CONFIG.canvas.width - this.width, this.x));

                const now = Date.now();
                if (gameState.shieldActive && now > gameState.shieldEndTime) {
                    gameState.shieldActive = false; this.isDefending = false;
                }
            },

            activateShield() {
                if (!gameState.daniInTeam) return;
                const now = Date.now();
                if (now - gameState.lastShieldTime < CONFIG.dani.shieldCooldown) return;
                gameState.shieldActive = true;
                gameState.shieldEndTime = now + CONFIG.dani.shieldDuration;
                gameState.lastShieldTime = now;
                this.isDefending = true;
                sounds.shield();
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#3498db', 12);
            },

            draw() {
                if (!gameState.daniInTeam) return;
                ctx.save();
                let s = images.daniIdle;
                if (this.isDefending) s = images.daniDefense;
                else if (this.isJumping) s = images.daniJump;
                else if (Math.abs(this.velocityX) > 0.5) s = images.daniRun;

                ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 3, this.width / 2.5, 8, 0, 0, Math.PI * 2); ctx.fill();

                if (gameState.shieldActive) {
                    ctx.globalAlpha = 0.3 + Math.sin(Date.now() * 0.005) * 0.15;
                    ctx.fillStyle = '#3498db';
                    ctx.beginPath();
                    ctx.ellipse(this.x + this.width / 2, this.y + this.height / 2, 100, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                if (!this.facingRight) { ctx.scale(-1, 1); ctx.drawImage(s, -this.x - this.width, this.y, this.width, this.height); }
                else ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        };

        // ===== ALICE (Fire Support) =====
        const alice = {
            x: 200, y: CONFIG.physics.groundY - CONFIG.alice.height,
            width: CONFIG.alice.width, height: CONFIG.alice.height,
            velocityX: 0, velocityY: 0, facingRight: true, isJumping: false,
            isAttacking: false, lastAttackTime: 0, isDamaged: false, lastDamageTime: 0,

            reset() {
                this.x = 200; this.y = CONFIG.physics.groundY - this.height;
                this.velocityX = 0; this.velocityY = 0; this.facingRight = true;
                this.isJumping = false; this.isAttacking = false; this.lastAttackTime = 0;
                this.isDamaged = false; this.lastDamageTime = 0;
            },

            update(dt) {
                if (!gameState.aliceInTeam) return;
                const now = Date.now();

                // Follow player at distance
                const tx = player.x + (player.facingRight ? -120 : 120);
                const dx = tx - this.x;
                if (Math.abs(dx) > 40) {
                    this.velocityX += Math.sign(dx) * 0.3;
                    this.velocityX = Math.max(-4.5, Math.min(4.5, this.velocityX));
                    this.facingRight = dx > 0;
                } else this.velocityX *= 0.8;

                if (player.isJumping && this.y >= CONFIG.physics.groundY - this.height - 5 && Math.abs(dx) < 200) {
                    this.velocityY = -10; this.isJumping = true;
                }

                this.velocityY += CONFIG.physics.gravity;
                this.x += this.velocityX; this.y += this.velocityY;
                if (this.y >= CONFIG.physics.groundY - this.height) { this.y = CONFIG.physics.groundY - this.height; this.velocityY = 0; this.isJumping = false; }
                this.x = Math.max(0, Math.min(CONFIG.canvas.width - this.width, this.x));

                if (this.isDamaged && now - this.lastDamageTime > 300) this.isDamaged = false;
                if (this.isAttacking && now - this.lastAttackTime > 600) this.isAttacking = false;

                // Auto fire attack when enemies nearby
                if (now - this.lastAttackTime > CONFIG.alice.attackCooldown) {
                    const alive = enemies.filter(e => !e.isDead);
                    const nearbyEnemies = alive.filter(e => {
                        const dist = Math.sqrt(Math.pow(e.x - this.x, 2) + Math.pow(e.y - this.y, 2));
                        return dist < CONFIG.alice.fireRadius;
                    });
                    if (nearbyEnemies.length > 0 || alive.length > 2) {
                        this.fireAttack();
                        this.lastAttackTime = now;
                    }
                }
            },

            fireAttack() {
                this.isAttacking = true;
                sounds.fire();

                const baseDmg = 10 + XP_SYSTEM.getStatBonus(gameState.playerLevel, 'attack') * 0.3;
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                // AoE fire damage
                enemies.forEach(e => {
                    if (e.isDead) return;
                    const dist = Math.sqrt(Math.pow(e.x + e.width/2 - cx, 2) + Math.pow(e.y + e.height/2 - cy, 2));
                    if (dist < CONFIG.alice.fireRadius) {
                        e.takeDamage(baseDmg);
                        // Apply burn
                        e.burnEnd = Date.now() + CONFIG.alice.burnDuration;
                        e.burnDamage = CONFIG.alice.burnDamage;
                    }
                });

                // Buff allies attack
                gameState.attackBuff = true;
                gameState.attackBuffEnd = Date.now() + CONFIG.alice.buffDuration;

                // Fire particles
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 / 20) * i;
                    gameState.particles.push({
                        x: cx + Math.cos(angle) * 30,
                        y: cy + Math.sin(angle) * 20,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 2 - 1,
                        life: 40, maxLife: 40, size: 6,
                        color: Math.random() > 0.5 ? '#e67e22' : '#f39c12'
                    });
                }
            },

            draw() {
                if (!gameState.aliceInTeam) return;
                ctx.save();
                let s = images.aliceIdle;
                if (this.isDamaged) s = images.aliceDamage;
                else if (this.isAttacking) s = images.aliceAttack;
                else if (Math.abs(this.velocityX) > 0.5) s = images.aliceRun;

                ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 3, this.width / 2.5, 8, 0, 0, Math.PI * 2); ctx.fill();

                // Fire aura when attacking
                if (this.isAttacking) {
                    ctx.globalAlpha = 0.25;
                    const grad = ctx.createRadialGradient(this.x + this.width/2, this.y + this.height/2, 10, this.x + this.width/2, this.y + this.height/2, CONFIG.alice.fireRadius);
                    grad.addColorStop(0, '#e67e22'); grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, CONFIG.alice.fireRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                if (!this.facingRight) { ctx.scale(-1, 1); ctx.drawImage(s, -this.x - this.width, this.y, this.width, this.height); }
                else ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        };

        // ===== VIT√ìRIA (Ice Support) =====
        const vitoria = {
            x: 240, y: CONFIG.physics.groundY - CONFIG.vitoria.height,
            width: CONFIG.vitoria.width, height: CONFIG.vitoria.height,
            velocityX: 0, velocityY: 0, facingRight: true, isJumping: false,
            currentSprite: 'idle', lastSkill1Time: 0, lastSkill2Time: 0, lastSkill3Time: 0,
            isDamaged: false, lastDamageTime: 0,

            reset() {
                this.x = 240; this.y = CONFIG.physics.groundY - this.height;
                this.velocityX = 0; this.velocityY = 0; this.facingRight = true;
                this.isJumping = false; this.currentSprite = 'idle';
                this.lastSkill1Time = 0; this.lastSkill2Time = 0; this.lastSkill3Time = 0;
                this.isDamaged = false; this.lastDamageTime = 0;
            },

            update(dt) {
                if (!gameState.vitoriaInTeam) return;
                const now = Date.now();

                const tx = player.x + (player.facingRight ? -150 : 150);
                const dx = tx - this.x;
                if (Math.abs(dx) > 40) {
                    this.velocityX += Math.sign(dx) * 0.3;
                    this.velocityX = Math.max(-4.5, Math.min(4.5, this.velocityX));
                    this.facingRight = dx > 0;
                } else this.velocityX *= 0.8;

                if (player.isJumping && this.y >= CONFIG.physics.groundY - this.height - 5 && Math.abs(dx) < 200) {
                    this.velocityY = -10; this.isJumping = true;
                }

                this.velocityY += CONFIG.physics.gravity;
                this.x += this.velocityX; this.y += this.velocityY;
                if (this.y >= CONFIG.physics.groundY - this.height) { this.y = CONFIG.physics.groundY - this.height; this.velocityY = 0; this.isJumping = false; }
                this.x = Math.max(0, Math.min(CONFIG.canvas.width - this.width, this.x));

                if (this.isDamaged && now - this.lastDamageTime > 300) this.isDamaged = false;

                // Update sprite state
                if (now - Math.max(this.lastSkill1Time, this.lastSkill2Time, this.lastSkill3Time) > 500) {
                    this.currentSprite = 'idle';
                }

                // Auto use skills
                const alive = enemies.filter(e => !e.isDead);
                // Skill 1: Ice blast (auto when enemy in range)
                if (alive.length > 0 && now - this.lastSkill1Time > CONFIG.vitoria.skill1Cooldown) {
                    const nearest = alive.reduce((a, b) => Math.abs(a.x - this.x) < Math.abs(b.x - this.x) ? a : b);
                    if (Math.abs(nearest.x - this.x) < CONFIG.vitoria.iceRange) {
                        this.skill1IceBlast(nearest);
                    }
                }
            },

            // Skill 1: Ice blast projectile
            skill1IceBlast(target) {
                this.lastSkill1Time = Date.now();
                this.currentSprite = 'attack1';
                this.facingRight = target.x > this.x;
                sounds.ice();

                const atk = 12 + XP_SYSTEM.getStatBonus(gameState.playerLevel, 'attack') * 0.4;
                gameState.projectiles.push({
                    x: this.x + this.width / 2, y: this.y + this.height / 2,
                    vx: (target.x > this.x ? 1 : -1) * 8,
                    damage: atk, life: 1, size: 12, type: 'ice',
                    freezeChance: CONFIG.vitoria.freezeChance
                });
            },

            // Skill 2: AoE ice explosion (manually triggered by player pressing L)
            skill2IceAoE() {
                if (!gameState.vitoriaInTeam) return;
                const now = Date.now();
                if (now - this.lastSkill2Time < CONFIG.vitoria.skill2Cooldown) return;
                this.lastSkill2Time = now;
                this.currentSprite = 'attack2';
                sounds.ice();

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                const dmg = 18 + XP_SYSTEM.getStatBonus(gameState.playerLevel, 'attack') * 0.5;

                // Damage nearby enemies + freeze chance
                enemies.forEach(e => {
                    if (e.isDead) return;
                    const dist = Math.sqrt(Math.pow(e.x + e.width/2 - cx, 2) + Math.pow(e.y + e.height/2 - cy, 2));
                    if (dist < 180) {
                        e.takeDamage(dmg);
                        if (Math.random() < 0.5) e.freeze(CONFIG.vitoria.freezeDuration);
                    }
                });

                // Give ice shield to allies
                gameState.iceShieldActive = true;
                gameState.iceShieldEnd = now + 4000;

                // Ice particles
                for (let i = 0; i < 25; i++) {
                    const angle = (Math.PI * 2 / 25) * i;
                    gameState.particles.push({
                        x: cx + Math.cos(angle) * 20,
                        y: cy + Math.sin(angle) * 15,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 3 - 2,
                        life: 45, maxLife: 45, size: 5,
                        color: Math.random() > 0.5 ? '#00bcd4' : '#4dd0e1'
                    });
                }
            },

            // Skill 3: Frost combo buff (manually triggered by player pressing L when skill2 is on cooldown)
            skill3FrostCombo() {
                if (!gameState.vitoriaInTeam) return;
                const now = Date.now();
                if (now - this.lastSkill3Time < CONFIG.vitoria.skill3Cooldown) return;
                this.lastSkill3Time = now;
                this.currentSprite = 'attack3';
                sounds.ice();

                // Each ally attack has increasing freeze chance
                gameState.frostComboActive = true;
                gameState.frostComboEnd = now + 8000;
                gameState.frostComboChance = 0.05;

                // Also buff attack
                gameState.attackBuff = true;
                gameState.attackBuffEnd = now + 8000;

                // Particles
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#4dd0e1', 15);
            },

            draw() {
                if (!gameState.vitoriaInTeam) return;
                ctx.save();
                let s = images.vitoriaIdle;
                if (this.isDamaged) s = images.vitoriaIdle; // no damage sprite available
                else if (this.currentSprite === 'attack1') s = images.vitoriaAttack1;
                else if (this.currentSprite === 'attack2') s = images.vitoriaAttack2;
                else if (this.currentSprite === 'attack3') s = images.vitoriaAttack3;
                else if (Math.abs(this.velocityX) > 0.5) s = images.vitoriaRun;

                ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 3, this.width / 2.5, 8, 0, 0, Math.PI * 2); ctx.fill();

                if (!this.facingRight) { ctx.scale(-1, 1); ctx.drawImage(s, -this.x - this.width, this.y, this.width, this.height); }
                else ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        };

        // ================ ENEMY ================
        class Enemy {
            constructor(x, stage) {
                this.width = 60; this.height = 80;
                this.x = x; this.y = CONFIG.physics.groundY - this.height;
                this.velocityX = 0; this.velocityY = 0;
                this.health = stage.enemyHealth; this.maxHealth = stage.enemyHealth;
                this.damage = stage.enemyDamage; this.speed = stage.enemySpeed;
                this.isDead = false; this.isDamaged = false; this.isAttacking = false;
                this.facingRight = x < CONFIG.canvas.width / 2;
                this.lastAttackTime = 0; this.lastDamageTime = 0;
                this.deathTime = 0; this.attackCooldown = 1200;
                this.burnEnd = 0; this.burnDamage = 0; this.lastBurnTick = 0;
                this.frozen = false; this.freezeEnd = 0;
            }

            freeze(duration) {
                this.frozen = true;
                this.freezeEnd = Date.now() + duration;
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#00bcd4', 8);
            }

            update(dt) {
                if (this.isDead) return;
                const now = Date.now();

                // Burn tick
                if (now < this.burnEnd && now - this.lastBurnTick > 500) {
                    this.health -= this.burnDamage;
                    this.lastBurnTick = now;
                    createParticles(this.x + this.width / 2, this.y, '#e67e22', 3);
                    createDamageIndicator(this.x + this.width / 2, this.y, this.burnDamage, '#e67e22');
                    if (this.health <= 0) { this.die(); return; }
                }

                // Freeze check
                if (this.frozen) {
                    if (now > this.freezeEnd) this.frozen = false;
                    else return; // Can't move while frozen
                }

                if (this.isDamaged && now - this.lastDamageTime > 200) this.isDamaged = false;
                if (this.isAttacking && now - this.lastAttackTime > 400) this.isAttacking = false;

                // Move toward player
                const dx = player.x - this.x;
                this.facingRight = dx > 0;
                if (Math.abs(dx) > 50) {
                    this.velocityX = Math.sign(dx) * this.speed;
                } else {
                    this.velocityX = 0;
                    if (now - this.lastAttackTime > this.attackCooldown) {
                        this.isAttacking = true; this.lastAttackTime = now;
                        if (checkCollision({ x: this.x - 20, y: this.y, width: this.width + 40, height: this.height }, player)) {
                            player.takeDamage(this.damage);
                        }
                    }
                }

                this.x += this.velocityX;
                this.x = Math.max(-50, Math.min(CONFIG.canvas.width + 50, this.x));
            }

            takeDamage(amount) {
                this.health -= amount; this.isDamaged = true; this.lastDamageTime = Date.now();
                sounds.hit();
                createDamageIndicator(this.x + this.width / 2, this.y, Math.round(amount));
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ffffff', 4);
                if (this.health <= 0) this.die();
            }

            die() {
                this.isDead = true; this.deathTime = Date.now();
                gameState.stageKills++;
                const sc = CONFIG.scoring.killBase * (1 + gameState.combo * 0.2);
                gameState.stageScore += Math.floor(sc);
                createParticles(this.x + this.width / 2, this.y + this.height / 2, '#ffd700', 10);
                checkStageComplete();
            }

            draw() {
                if (this.isDead) {
                    if (Date.now() - this.deathTime < 600) {
                        ctx.save(); ctx.globalAlpha = Math.max(0, 1 - (Date.now() - this.deathTime) / 600);
                        ctx.drawImage(images.enemyDead, this.x, this.y, this.width, this.height);
                        ctx.restore();
                    }
                    return;
                }

                ctx.save();
                let s = images.enemyIdle;
                if (this.isDamaged) s = images.enemyDamage;
                else if (this.isAttacking) s = images.enemyAttack;
                else if (Math.abs(this.velocityX) > 0.3) s = this.facingRight ? images.enemyWalkR : images.enemyWalkL;

                ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath();
                ctx.ellipse(this.x + this.width / 2, CONFIG.physics.groundY + 3, this.width / 2, 7, 0, 0, Math.PI * 2); ctx.fill();

                // Frozen effect
                if (this.frozen) {
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#00bcd4';
                    ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                    ctx.globalAlpha = 1;
                }

                // Burn effect
                if (Date.now() < this.burnEnd) {
                    ctx.globalAlpha = 0.2 + Math.sin(Date.now() * 0.01) * 0.1;
                    ctx.fillStyle = '#e67e22';
                    ctx.fillRect(this.x - 3, this.y - 3, this.width + 6, this.height + 6);
                    ctx.globalAlpha = 1;
                }

                // Health bar
                const hpPct = this.health / this.maxHealth;
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(this.x, this.y - 10, this.width, 5);
                ctx.fillStyle = hpPct > 0.5 ? '#4caf50' : hpPct > 0.25 ? '#ff9800' : '#f44336';
                ctx.fillRect(this.x, this.y - 10, this.width * hpPct, 5);

                ctx.drawImage(s, this.x, this.y, this.width, this.height);
                ctx.restore();
            }
        }

        // ================ PARTICLES & EFFECTS ================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6 - 2,
                    life: 30 + Math.random() * 20, maxLife: 50, size: 3 + Math.random() * 4, color
                });
            }
        }
        function updateParticles() {
            gameState.particles = gameState.particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; return p.life > 0; });
        }
        function drawParticles() {
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function createDamageIndicator(x, y, amount, color) {
            gameState.damageIndicators.push({ x, y, text: `-${amount}`, life: 40, color: color || '#ff6b6b' });
        }
        function updateDamageIndicators() {
            gameState.damageIndicators = gameState.damageIndicators.filter(d => { d.y -= 1.5; d.life--; return d.life > 0; });
        }
        function drawDamageIndicators() {
            gameState.damageIndicators.forEach(d => {
                ctx.globalAlpha = d.life / 40;
                ctx.fillStyle = d.color; ctx.font = 'bold 16px "Press Start 2P"';
                ctx.textAlign = 'center'; ctx.fillText(d.text, d.x, d.y);
            });
            ctx.globalAlpha = 1;
        }

        function showCombo(combo) {
            el.comboDisplay.textContent = `${combo}x COMBO!`;
            el.comboDisplay.classList.remove('active');
            void el.comboDisplay.offsetWidth;
            el.comboDisplay.classList.add('active');
        }

        function updateProjectiles() {
            gameState.projectiles = gameState.projectiles.filter(p => {
                p.x += p.vx; p.life -= 0.02;
                if (p.x < -50 || p.x > CONFIG.canvas.width + 50 || p.life <= 0) return false;

                for (let e of enemies) {
                    if (!e.isDead && checkCollision({ x: p.x - p.size, y: p.y - p.size, width: p.size * 2, height: p.size * 2 }, e)) {
                        e.takeDamage(p.damage);
                        if (p.type === 'ice' && p.freezeChance && Math.random() < p.freezeChance) {
                            e.freeze(CONFIG.vitoria.freezeDuration);
                        }
                        createParticles(p.x, p.y, p.type === 'ice' ? '#00bcd4' : '#ffe082', 5);
                        return false;
                    }
                }
                return true;
            });
        }

        function drawProjectiles() {
            gameState.projectiles.forEach(p => {
                ctx.save();
                if (p.type === 'ice') {
                    ctx.fillStyle = '#00bcd4'; ctx.shadowColor = '#00bcd4'; ctx.shadowBlur = 12;
                } else {
                    ctx.fillStyle = '#ffe082'; ctx.shadowColor = '#ffb300'; ctx.shadowBlur = 10;
                }
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });
        }

        function updateScreenShake() {
            if (gameState.screenShake.intensity > 0) {
                gameState.screenShake.x = (Math.random() - 0.5) * gameState.screenShake.intensity;
                gameState.screenShake.y = (Math.random() - 0.5) * gameState.screenShake.intensity;
                gameState.screenShake.intensity *= 0.9;
                if (gameState.screenShake.intensity < 0.5) gameState.screenShake.intensity = 0;
            }
        }

        // Spawning
        function spawnEnemy() {
            const stage = gameState.currentStage; if (!stage) return;
            if (enemies.length >= stage.maxEnemies) return;
            if (stage.mission.type === 'kill' && gameState.stageKills >= stage.mission.target) return;
            const side = Math.random() > 0.5 ? 1 : -1;
            enemies.push(new Enemy(side === 1 ? CONFIG.canvas.width + 50 : -60, stage));
        }

        // Stage Complete Check
        function checkStageComplete() {
            const stage = gameState.currentStage; if (!stage || gameState.stageComplete) return;
            let completed = false;
            if (stage.mission.type === 'kill') {
                if (gameState.stageKills >= stage.mission.target && enemies.filter(e => !e.isDead).length === 0) completed = true;
            } else if (stage.mission.type === 'combo') {
                if (gameState.stageMaxCombo >= stage.mission.target) completed = true;
            }
            if (completed) showResults(true);
        }

        // ================ RESULTS SCREEN ================
        function showResults(victory) {
            gameState.stageComplete = true;
            gameState.running = false;

            const stage = gameState.currentStage;
            const elapsed = Math.floor((Date.now() - gameState.stageStartTime) / 1000);

            let xpGained = 0;
            let unlockedCharName = null;

            if (victory) {
                xpGained = stage.xpReward;
                if (gameState.stageDamageTaken === 0) xpGained += 50;
                if (gameState.stageMaxCombo >= 5) xpGained += 30;

                const prevLevel = gameState.playerLevel;
                gameState.totalXp += xpGained;
                gameState.totalScore += gameState.stageScore;
                const li = XP_SYSTEM.getLevelFromXp(gameState.totalXp);
                gameState.playerLevel = li.level; gameState.currentXp = li.currentXp; gameState.xpToNextLevel = li.neededXp;

                if (stage.id >= gameState.highestStage) gameState.highestStage = stage.id + 1;

                let stars = 1;
                if (gameState.stageDamageTaken === 0) stars = 3;
                else if (gameState.stageDamageTaken < 30) stars = 2;
                if (!gameState.stageStars[stage.id] || gameState.stageStars[stage.id] < stars) gameState.stageStars[stage.id] = stars;

                // Check character unlock
                if (stage.unlockChar && !gameState.unlockedChars[stage.unlockChar]) {
                    gameState.unlockedChars[stage.unlockChar] = true;
                    const charNames = {
                        sarah: 'Sarah (Atacante)',
                        dani: 'Dani (Defensora)',
                        alice: 'Alice (Suporte Fogo)',
                        vitoria: 'Vit√≥ria (Suporte Gelo)'
                    };
                    unlockedCharName = charNames[stage.unlockChar] || stage.unlockChar;
                    sounds.unlock();
                }

                saveProgress();
                sounds.stageComplete();

                el.resultsTitle.textContent = 'FASE COMPLETA!';
                el.resultsTitle.className = 'results-title victory';
                el.resultXp.textContent = `+${xpGained} XP`; el.resultXp.style.display = 'block';
                el.resultLevelUp.style.display = gameState.playerLevel > prevLevel ? 'block' : 'none';
                if (gameState.playerLevel > prevLevel) sounds.levelUp();
            } else {
                sounds.gameOver();
                el.resultsTitle.textContent = 'DERROTA';
                el.resultsTitle.className = 'results-title defeat';
                el.resultXp.style.display = 'none';
                el.resultLevelUp.style.display = 'none';
            }

            el.resultsGrid.innerHTML = `
                <div class="result-card"><div class="result-card-value">${stage.name}</div><div class="result-card-label">Fase</div></div>
                <div class="result-card"><div class="result-card-value">${gameState.stageScore.toLocaleString()}</div><div class="result-card-label">Pontos</div></div>
                <div class="result-card"><div class="result-card-value">${gameState.stageKills}</div><div class="result-card-label">Derrotados</div></div>
                <div class="result-card"><div class="result-card-value">${gameState.stageMaxCombo}x</div><div class="result-card-label">Max Combo</div></div>
                <div class="result-card"><div class="result-card-value">${elapsed}s</div><div class="result-card-label">Tempo</div></div>
                <div class="result-card"><div class="result-card-value">${gameState.stageDamageTaken}</div><div class="result-card-label">Dano Recebido</div></div>
            `;

            if (unlockedCharName) {
                el.resultUnlock.textContent = `üéâ ${unlockedCharName.toUpperCase()} DESBLOQUEADA! üéâ`;
                el.resultUnlock.style.display = 'block';
            } else {
                el.resultUnlock.style.display = 'none';
            }

            // Buttons
            el.resultsButtons.innerHTML = '';
            if (victory) {
                const nextStageId = stage.id + 1;
                const nextStage = STAGES_DATA.find(s => s.id === nextStageId);
                const isLastInWorld = !nextStage || nextStage.world !== stage.world;

                if (isLastInWorld || nextStageId > 30) {
                    const mapBtn = document.createElement('button');
                    mapBtn.className = 'game-btn game-btn-secondary';
                    mapBtn.innerHTML = 'üó∫Ô∏è VOLTAR AO MAPA';
                    mapBtn.addEventListener('click', () => { hideResults(); showStageSelect(); });
                    el.resultsButtons.appendChild(mapBtn);
                } else {
                    const mapBtn = document.createElement('button');
                    mapBtn.className = 'game-btn game-btn-secondary';
                    mapBtn.innerHTML = 'üó∫Ô∏è MAPA';
                    mapBtn.addEventListener('click', () => { hideResults(); showStageSelect(); });
                    el.resultsButtons.appendChild(mapBtn);

                    const nextBtn = document.createElement('button');
                    nextBtn.className = 'game-btn game-btn-primary';
                    nextBtn.innerHTML = 'PR√ìXIMA FASE ‚Üí';
                    nextBtn.addEventListener('click', () => { hideResults(); startStage(nextStageId); });
                    el.resultsButtons.appendChild(nextBtn);
                }
            } else {
                const retryBtn = document.createElement('button');
                retryBtn.className = 'game-btn game-btn-danger';
                retryBtn.innerHTML = 'üîÑ TENTAR NOVAMENTE';
                retryBtn.addEventListener('click', () => { hideResults(); startStage(stage.id); });
                el.resultsButtons.appendChild(retryBtn);

                const mapBtn = document.createElement('button');
                mapBtn.className = 'game-btn game-btn-secondary';
                mapBtn.innerHTML = 'üó∫Ô∏è MAPA';
                mapBtn.addEventListener('click', () => { hideResults(); showStageSelect(); });
                el.resultsButtons.appendChild(mapBtn);
            }

            el.hudOverlay.style.display = 'none';
            el.stageIndicator.style.display = 'none';
            el.missionIndicator.style.display = 'none';
            el.supportCooldown.style.display = 'none';
            el.controlsPanel.style.display = 'none';

            setTimeout(() => el.resultsScreen.classList.add('active'), victory ? 1000 : 500);
        }

        function hideResults() { el.resultsScreen.classList.remove('active'); }

        // HUD
        function updateHUD() {
            el.healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            el.xpBar.style.width = `${(gameState.currentXp / gameState.xpToNextLevel) * 100}%`;
            el.levelDisplay.textContent = `Lv.${gameState.playerLevel}`;
            const stage = gameState.currentStage;
            if (stage && stage.mission.type === 'kill') el.killsDisplay.textContent = `${gameState.stageKills}/${stage.mission.target}`;
            else if (stage) el.killsDisplay.textContent = gameState.stageKills;
            el.scoreDisplay.textContent = gameState.stageScore.toLocaleString();

            if (gameState.daniInTeam) {
                const now = Date.now();
                const cd = Math.max(0, CONFIG.dani.shieldCooldown - (now - gameState.lastShieldTime));
                if (cd > 0) { el.supportCooldown.textContent = `üõ°Ô∏è SHIELD: ${Math.ceil(cd / 1000)}s`; el.supportCooldown.style.color = '#888'; }
                else { el.supportCooldown.textContent = 'üõ°Ô∏è SHIELD: PRONTO (K)'; el.supportCooldown.style.color = '#3498db'; }
            }
        }

        // Drawing
        function drawBackground() {
            const grad = ctx.createLinearGradient(0, 0, 0, CONFIG.physics.groundY);
            grad.addColorStop(0, '#1a2c4a'); grad.addColorStop(0.5, '#2d4a6d'); grad.addColorStop(1, '#3d5a80');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.physics.groundY);

            if (images.background.complete && images.background.naturalWidth > 0) {
                const bw = images.background.width || CONFIG.canvas.width;
                const off = gameState.backgroundOffset % bw;
                for (let i = -1; i <= Math.ceil(CONFIG.canvas.width / bw) + 1; i++) ctx.drawImage(images.background, off + i * bw, 0, bw, CONFIG.physics.groundY);
            }

            ctx.fillStyle = '#3a5a40'; ctx.fillRect(0, CONFIG.physics.groundY, CONFIG.canvas.width, CONFIG.canvas.height - CONFIG.physics.groundY);
            ctx.fillStyle = '#588157';
            for (let i = 0; i < 35; i++) { const x = ((i * 40 + gameState.backgroundOffset * 0.5) % (CONFIG.canvas.width + 50)) - 25; ctx.fillRect(x, CONFIG.physics.groundY - 3, 25, 8); }
            ctx.strokeStyle = '#4a7a5a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, CONFIG.physics.groundY); ctx.lineTo(CONFIG.canvas.width, CONFIG.physics.groundY); ctx.stroke();
        }

        // Game Loop
        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameState.running) return;
            const dt = timestamp - lastTime; lastTime = timestamp;

            if (gameState.paused || gameState.stageComplete) { requestAnimationFrame(gameLoop); return; }

            ctx.clearRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
            ctx.save(); ctx.translate(gameState.screenShake.x, gameState.screenShake.y);

            player.update(dt); sarah.update(dt); dani.update(dt); alice.update(dt); vitoria.update(dt);
            enemies.forEach(e => e.update(dt));
            updateParticles(); updateDamageIndicators(); updateScreenShake(); updateProjectiles();

            // Clear expired buffs
            const now = Date.now();
            if (gameState.attackBuff && now > gameState.attackBuffEnd) gameState.attackBuff = false;
            if (gameState.iceShieldActive && now > gameState.iceShieldEnd) gameState.iceShieldActive = false;
            if (gameState.frostComboActive && now > gameState.frostComboEnd) gameState.frostComboActive = false;

            gameState.backgroundOffset -= player.velocityX * 0.3;

            const stage = gameState.currentStage;
            if (stage && now - gameState.lastSpawnTime > stage.spawnRate) { spawnEnemy(); gameState.lastSpawnTime = now; }
            if (now - gameState.lastComboTime > CONFIG.scoring.comboTimeout && gameState.combo > 0) gameState.combo = 0;

            if (stage && stage.mission.type === 'survive') {
                const elapsed = (now - gameState.stageStartTime) / 1000;
                if (elapsed >= stage.mission.target) showResults(true);
            }

            updateHUD();

            drawBackground();
            enemies.forEach(e => e.draw());
            dani.draw(); alice.draw(); vitoria.draw(); sarah.draw(); player.draw();
            drawProjectiles(); drawParticles(); drawDamageIndicators();

            ctx.restore();
            requestAnimationFrame(gameLoop);
        }

        // Game States
        function startStage(stageId) {
            initAudio();
            const stage = STAGES_DATA.find(s => s.id === stageId);
            if (!stage || stageId > gameState.highestStage) return;

            gameState.currentStage = stage;
            gameState.running = true; gameState.paused = false; gameState.stageComplete = false; gameState.playerDied = false;
            gameState.stageKills = 0; gameState.stageScore = 0; gameState.stageDamageTaken = 0;
            gameState.stageMaxCombo = 0; gameState.combo = 0; gameState.lastComboTime = 0;
            gameState.lastSpawnTime = Date.now(); gameState.lastShieldTime = 0;
            gameState.stageStartTime = Date.now(); gameState.backgroundOffset = 0;
            gameState.particles = []; gameState.damageIndicators = []; gameState.projectiles = [];
            gameState.screenShake = { x: 0, y: 0, intensity: 0 };
            gameState.shieldActive = false; gameState.shieldEndTime = 0;
            gameState.attackBuff = false; gameState.attackBuffEnd = 0;
            gameState.iceShieldActive = false; gameState.iceShieldEnd = 0;
            gameState.frostComboActive = false; gameState.frostComboEnd = 0; gameState.frostComboChance = 0;

            gameState.sarahInTeam = gameState.selectedCharacters.includes('sarah');
            gameState.daniInTeam = gameState.selectedCharacters.includes('dani');
            gameState.aliceInTeam = gameState.selectedCharacters.includes('alice');
            gameState.vitoriaInTeam = gameState.selectedCharacters.includes('vitoria');

            player.reset(); sarah.reset(); dani.reset(); alice.reset(); vitoria.reset();
            enemies = [];

            // Update mobile skill buttons visibility
            const sk1 = document.getElementById('mobileSkill1');
            const sk2 = document.getElementById('mobileSkill2');
            sk1.style.display = gameState.aliceInTeam ? 'flex' : 'none';
            sk2.style.display = gameState.vitoriaInTeam ? 'flex' : 'none';

            el.stageSelectScreen.classList.remove('active');
            el.resultsScreen.classList.remove('active');
            el.hudOverlay.style.display = 'flex';
            el.stageIndicator.style.display = 'block'; el.stageIndicator.textContent = `FASE ${stage.name}`;
            el.missionIndicator.style.display = 'block'; el.missionIndicator.textContent = stage.mission.text;
            el.controlsPanel.style.display = window.innerWidth > 768 ? 'grid' : 'none';
            el.supportCooldown.style.display = gameState.daniInTeam ? 'block' : 'none';

            updateHUD();
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            gameState.playerDied = true;
            showResults(false);
        }

        function togglePause() {
            if (!gameState.running || gameState.stageComplete) return;
            gameState.paused = !gameState.paused;
            el.pauseOverlay.classList.toggle('active', gameState.paused);
        }

        // Stage Select UI
        let currentWorld = 1, selectedStageId = 1;

        function renderWorldTabs() {
            el.worldTabs.innerHTML = '';
            WORLDS.forEach((w, i) => {
                const tab = document.createElement('button');
                tab.className = `world-tab ${i + 1 === currentWorld ? 'active' : ''}`;
                tab.textContent = `${i + 1}. ${w}`;
                tab.addEventListener('click', () => { currentWorld = i + 1; renderWorldTabs(); renderStageGrid(); });
                el.worldTabs.appendChild(tab);
            });
        }

        function renderStageGrid() {
            el.stageGrid.innerHTML = '';
            STAGES_DATA.filter(s => s.world === currentWorld).forEach(stage => {
                const node = document.createElement('div');
                node.className = 'stage-node';
                const unlocked = stage.id <= gameState.highestStage;
                const completed = gameState.stageStars[stage.id] > 0;
                const isCurrent = stage.id === gameState.highestStage;

                if (completed) node.classList.add('completed');
                else if (unlocked) { node.classList.add('unlocked'); if (isCurrent) node.classList.add('current'); }
                else node.classList.add('locked');

                node.innerHTML = `<div class="stage-number">${stage.stageInWorld}</div><div class="stage-stars">${'‚≠ê'.repeat(gameState.stageStars[stage.id] || 0)}</div>`;
                if (unlocked) node.addEventListener('click', () => selectStage(stage.id));
                el.stageGrid.appendChild(node);
            });
        }

        function selectStage(stageId) {
            selectedStageId = stageId;
            const stage = STAGES_DATA.find(s => s.id === stageId);
            if (!stage) return;
            el.stageInfoPanel.style.display = 'block';
            el.stageInfoTitle.textContent = `FASE ${stage.name} - ${stage.worldName}`;
            el.stageInfoMission.textContent = stage.mission.text;
            el.stageXpReward.textContent = stage.xpReward;
            el.stageScoreReward.textContent = stage.scoreReward;
            renderTeamSelect();
        }

        function renderTeamSelect() {
            el.teamSelectMini.innerHTML = '';
            const chars = [
                { id: 'lia', name: 'Lia', role: 'Guerreira', img: 'lia.png', always: true },
                { id: 'sarah', name: 'Sarah', role: 'Atacante', img: 'sarah.png', always: false },
                { id: 'dani', name: 'Dani', role: 'Defensora', img: 'dani.png', always: false },
                { id: 'alice', name: 'Alice', role: 'Suporte üî•', img: 'alice.png', always: false },
                { id: 'vitoria', name: 'Vit√≥ria', role: 'Suporte ‚ùÑÔ∏è', img: 'vitoria.png', always: false }
            ];

            chars.forEach(c => {
                const div = document.createElement('div');
                const unlocked = c.always || gameState.unlockedChars[c.id];
                const selected = c.always || gameState.selectedCharacters.includes(c.id);
                div.className = `team-char-mini ${selected ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
                div.innerHTML = `<img src="${c.img}" alt="${c.name}"><div class="char-name">${c.name}</div><div class="char-role">${c.role}</div>`;

                if (unlocked && !c.always) {
                    div.addEventListener('click', () => {
                        if (gameState.selectedCharacters.includes(c.id)) {
                            gameState.selectedCharacters = gameState.selectedCharacters.filter(x => x !== c.id);
                        } else if (gameState.selectedCharacters.length < 3) {
                            gameState.selectedCharacters.push(c.id);
                        }
                        renderTeamSelect();
                    });
                }
                el.teamSelectMini.appendChild(div);
            });
        }

        function updatePlayerStats() {
            el.playerLevelStat.textContent = `Lv. ${gameState.playerLevel}`;
            el.playerXpStat.textContent = gameState.totalXp.toLocaleString();
            let ts = 0; Object.values(gameState.stageStars).forEach(s => ts += s);
            el.playerStarsStat.textContent = ts;
        }

        function showStageSelect() {
            updatePlayerStats(); renderWorldTabs(); renderStageGrid();
            el.mainMenuScreen.classList.remove('active');
            el.resultsScreen.classList.remove('active');
            el.stageSelectScreen.classList.add('active');
            el.hudOverlay.style.display = 'none'; el.stageIndicator.style.display = 'none';
            el.missionIndicator.style.display = 'none'; el.supportCooldown.style.display = 'none';
            el.controlsPanel.style.display = 'none';
            selectStage(Math.min(gameState.highestStage, 30));
        }

        // Input
        document.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase(); gameState.keys[k] = true;
            if (!gameState.running) return;
            if ((k === 'w' || k === ' ' || k === 'arrowup') && !gameState.paused) { player.jump(); e.preventDefault(); }
            if (k === 'j' && !gameState.paused) player.attack();
            if (k === 'k' && !gameState.paused) {
                // K = Dani shield or Vit√≥ria skill2
                if (gameState.daniInTeam) dani.activateShield();
                else if (gameState.vitoriaInTeam) vitoria.skill2IceAoE();
            }
            if (k === 'l' && !gameState.paused) {
                // L = Vit√≥ria skill3 (frost combo buff)
                if (gameState.vitoriaInTeam) vitoria.skill3FrostCombo();
            }
            if (k === 'escape' || k === 'p') togglePause();
            if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(k)) e.preventDefault();
        });
        document.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase(); gameState.keys[k] = false;
            if (k === 'w' || k === ' ' || k === 'arrowup') player.releaseJump();
        });

        // Mobile Controls
        function setupMobileControls() {
            const ts = (key, action) => (e) => { e.preventDefault(); gameState.keys[key] = true; if (action) action(); };
            const te = (key, action) => (e) => { e.preventDefault(); gameState.keys[key] = false; if (action) action(); };

            document.getElementById('mobileLeft').addEventListener('touchstart', ts('a'));
            document.getElementById('mobileLeft').addEventListener('touchend', te('a'));
            document.getElementById('mobileRight').addEventListener('touchstart', ts('d'));
            document.getElementById('mobileRight').addEventListener('touchend', te('d'));
            document.getElementById('mobileJump').addEventListener('touchstart', ts('jump', () => player.jump()));
            document.getElementById('mobileJump').addEventListener('touchend', te('jump', () => player.releaseJump()));
            document.getElementById('mobileAttack').addEventListener('touchstart', ts('attack', () => player.attack()));
            document.getElementById('mobileAttack').addEventListener('touchend', te('attack'));
            document.getElementById('mobileSupport').addEventListener('touchstart', ts('support', () => dani.activateShield()));
            document.getElementById('mobileSupport').addEventListener('touchend', te('support'));
            document.getElementById('mobileSkill1').addEventListener('touchstart', ts('skill1', () => {
                // Alice fire attack is auto, this triggers Vit√≥ria skill2 if alice not in team
                if (gameState.vitoriaInTeam) vitoria.skill2IceAoE();
            }));
            document.getElementById('mobileSkill1').addEventListener('touchend', te('skill1'));
            document.getElementById('mobileSkill2').addEventListener('touchstart', ts('skill2', () => {
                if (gameState.vitoriaInTeam) vitoria.skill3FrostCombo();
            }));
            document.getElementById('mobileSkill2').addEventListener('touchend', te('skill2'));
        }

        // Event Listeners
        document.getElementById('titleStartBtn').addEventListener('click', () => { initAudio(); el.titleScreen.classList.remove('active'); el.mainMenuScreen.classList.add('active'); });
        document.getElementById('playGameBtn').addEventListener('click', showStageSelect);
        document.getElementById('googleLoginBtn').addEventListener('click', () => {
            alert('Login com Google ser√° implementado em breve! Por enquanto, seus dados N√ÉO ser√£o salvos.');
        });
        document.getElementById('backToMenuBtn').addEventListener('click', () => { el.stageSelectScreen.classList.remove('active'); el.mainMenuScreen.classList.add('active'); });
        document.getElementById('playStageBtn').addEventListener('click', () => { startStage(selectedStageId); });

        // Initialize
        setupMobileControls();
        gameState.selectedCharacters = ['lia'];
        if ('ontouchstart' in window) el.mobileControls.style.display = 'flex';
    </script>
</body>
</html>
